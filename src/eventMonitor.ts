import 'dotenv/config';
import {
  createPublicClient,
  http,
  webSocket,
  parseAbi,
  type Address,
  type PublicClient,
  type Log,
} from 'viem';
import { config } from './config.js';
import {
  LPFarmingLogger,
  type BinChangeData,
  type LPOpportunityData,
  type APRTrackingData,
  type DetailedPoolData,
} from './csvLogger.js';
import {
  price1Per0FromSqrt,
  price1Per0FromSqrtPrecise,
  analyzeBinEdges,
  calculateAPR,
  calculateImpermanentLoss,
  calculateMedian,
  calculateOptimalLPRange,
  isPriceInRange,
  type BinEdgeAnalysis,
  type APRCalculation,
} from './mathUtils.js';

// Network Configuration v·ªõi automatic fallback
const createChainConfig = (useKatana: boolean = true) => {
  if (useKatana && process.env.FORCE_MAINNET !== 'true') {
    // Katana Network (Ronin) Configuration
    return {
      id: 2020,
      name: 'Katana',
      nativeCurrency: { name: 'Ronin', symbol: 'RON', decimals: 18 },
      rpcUrls: {
        default: {
          http: ['https://api.roninchain.com/rpc'],
          webSocket: config.RPC_WS ? [config.RPC_WS] : undefined,
        },
      },
    } as const;
  } else {
    // Ethereum Mainnet Fallback v·ªõi multiple RPC endpoints
    return {
  id: 1,
  name: 'Ethereum',
  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
  rpcUrls: {
    default: {
          http: [
            'https://ethereum.publicnode.com', // Reliable, supports all methods
            'https://ethereum-rpc.publicnode.com', // Good, supports all methods
            'https://eth.drpc.org', // Fast, supports all methods
            'https://rpc.flashbots.net', // Good, supports all methods
            'https://eth.merkle.io', // Reliable, supports all methods
            config.RPC_FALLBACK_HTTP || 'https://cloudflare-eth.com',
          ],
      webSocket: config.RPC_WS ? [config.RPC_WS] : undefined,
    },
  },
} as const;
  }
};

// Default chain configuration
let CHAIN_CONFIG = createChainConfig(true);

// Essential ABIs
const poolAbi = parseAbi([
  'function token0() view returns (address)',
  'function token1() view returns (address)',
  'function fee() view returns (uint24)',
  'function tickSpacing() view returns (int24)',
  'function liquidity() view returns (uint128)',
  'function slot0() view returns (uint160 sqrtPriceX96,int24 tick,uint16 observationIndex,uint16 observationCardinality,uint16 observationCardinalityNext,uint8 feeProtocol,bool unlocked)',
]);

const erc20Abi = parseAbi([
  'function decimals() view returns (uint8)',
  'function symbol() view returns (string)',
]);

const swapEventAbi = parseAbi([
  'event Swap(address sender,address recipient,int256 amount0,int256 amount1,uint160 sqrtPriceX96,uint128 liquidity,int24 tick)',
]);

// ==================== LP FARMING MONITOR CLASS ====================

class LPFarmingMonitor {
  private client: any; // Use any type to avoid strict typing issues with chain configs
  private logger: LPFarmingLogger;
  private poolAddress: Address;

  // Pool configuration
  private token0Address?: Address;
  private token1Address?: Address;
  private fee?: number;
  private tickSpacing?: number;
  private token0Decimals?: number;
  private token1Decimals?: number;
  private token0Symbol?: string;
  private token1Symbol?: string;

  // Bin tracking state
  private currentBin?: number;
  private previousBin?: number;
  private lastBinChangeTimestamp?: number;
  private currentPrecisePrice?: string;
  private currentEdgeAnalysis?: BinEdgeAnalysis;
  private binHistory: Array<{ bin: number; timestamp: number; price: number }> =
    [];
  private binDurations: number[] = [];

  // Market data tracking
  private priceHistory: Array<{ price: number; timestamp: number }> = [];
  private volumeHistory: Array<{ volume: number; timestamp: number }> = [];
  private feesCollected: number = 0;
  private totalValueLocked: number = 0;

  // Performance tracking
  private monitorStartTime: number;
  private lastAPRUpdate: number = 0;
  private consecutiveSafeOpportunities: number = 0;

  // Dashboard state
  private dashboardInterval?: NodeJS.Timeout;

  constructor() {
    // Initialize with first chain config attempt
    this.client = this.createClientWithConfig(CHAIN_CONFIG);
    this.logger = new LPFarmingLogger();
    this.poolAddress = config.POOL;
    this.monitorStartTime = Date.now();
  }

  private createClientWithConfig(chainConfig: any): any {
    const rpcUrls = Array.isArray(chainConfig.rpcUrls.default.http)
      ? chainConfig.rpcUrls.default.http
      : [chainConfig.rpcUrls.default.http];

    // Use first RPC URL for now, we'll implement fallback in testConnection
    const primaryRpc = rpcUrls[0];

    return createPublicClient({
      chain: chainConfig,
      transport: config.RPC_WS
        ? webSocket(config.RPC_WS, {
            timeout: 15000,
            retryCount: 3,
          })
        : http(primaryRpc, {
            timeout: 15000,
            retryCount: 3,
          }),
    });
  }

  private async testConnection(): Promise<boolean> {
    const rpcUrls = Array.isArray(CHAIN_CONFIG.rpcUrls.default.http)
      ? CHAIN_CONFIG.rpcUrls.default.http
      : [CHAIN_CONFIG.rpcUrls.default.http];

    for (let i = 0; i < rpcUrls.length; i++) {
      try {
        console.log(
          `üîó Testing connection to ${CHAIN_CONFIG.name} (${i + 1}/${
            rpcUrls.length
          })...`
        );

        // Create temporary client with this RPC
        const tempClient = createPublicClient({
          chain: CHAIN_CONFIG,
          transport: http(rpcUrls[i], {
            timeout: 10000,
            retryCount: 1,
          }),
        });

        const blockNumber = await tempClient.getBlockNumber();
        console.log(`‚úÖ Connected successfully! Latest block: ${blockNumber}`);

        // Update main client to use working RPC
        this.client = tempClient;
        return true;
      } catch (error) {
        console.log(
          `‚ùå RPC ${i + 1} failed:`,
          error instanceof Error ? error.message : error
        );
        if (i === rpcUrls.length - 1) {
          console.log(
            `‚ùå All ${rpcUrls.length} RPC endpoints failed for ${CHAIN_CONFIG.name}`
          );
        }
      }
    }
    return false;
  }

  async initialize(): Promise<void> {
    console.log('üéØ Kh·ªüi t·∫°o LP Farming Monitor...');

    // Test connection v√† fallback n·∫øu c·∫ßn
    let connectionSuccessful = await this.testConnection();

    if (!connectionSuccessful) {
      console.log(
        'üîÑ Katana connection failed, falling back to Ethereum mainnet...'
      );

      // Update chain config to mainnet
      CHAIN_CONFIG = createChainConfig(false);
      this.client = this.createClientWithConfig(CHAIN_CONFIG);

      // Update pool address to mainnet USDC/WETH pool for testing
      this.poolAddress =
        '0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640' as `0x${string}`;
      console.log(`üìç Using Mainnet Pool: ${this.poolAddress}`);

      // Test mainnet connection
      connectionSuccessful = await this.testConnection();

      if (!connectionSuccessful) {
        throw new Error('‚ùå Both Katana and Mainnet connections failed!');
      }
    } else {
      console.log(`üìç Using ${CHAIN_CONFIG.name} Pool: ${this.poolAddress}`);
    }

    try {
      await this.loadPoolConfiguration();
      await this.initializeHistoricalData();
      this.logger.getLogSummary();

      console.log('‚úÖ LP Farming Monitor ƒë√£ s·∫µn s√†ng!');
      console.log(`üåê Network: ${CHAIN_CONFIG.name}`);
      console.log(`üéØ Target Pool: ${this.token0Symbol}/${this.token1Symbol}`);
      console.log(`üí∞ Fee Tier: ${this.fee ? this.fee / 10000 : 'Unknown'}%`);
      console.log(`üìè Tick Spacing: ${this.tickSpacing}`);
    } catch (error) {
      console.error('‚ùå Pool configuration failed on', CHAIN_CONFIG.name);

      // If we're still on Katana and pool doesn't work, fallback to mainnet
      if (CHAIN_CONFIG.name === 'Katana') {
        console.log(
          'üîÑ Pool not compatible with Katana, falling back to Ethereum mainnet...'
        );

        // Update chain config to mainnet
        CHAIN_CONFIG = createChainConfig(false);
        this.client = this.createClientWithConfig(CHAIN_CONFIG);

        // Update pool address to mainnet USDC/WETH pool
        this.poolAddress =
          '0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640' as `0x${string}`;
        console.log(`üìç Using Mainnet USDC/WETH Pool: ${this.poolAddress}`);

        // Test mainnet connection with retry
        let mainnetConnection = false;
        for (let attempt = 1; attempt <= 3; attempt++) {
          console.log(`üîÑ Mainnet connection attempt ${attempt}/3...`);
          mainnetConnection = await this.testConnection();
          if (mainnetConnection) break;
          if (attempt < 3) {
            console.log('‚è≥ Waiting 2 seconds before retry...');
            await new Promise((resolve) => setTimeout(resolve, 2000));
          }
        }

        if (!mainnetConnection) {
          throw new Error('‚ùå All mainnet RPC endpoints failed!');
        }

        // Retry with mainnet pool
        try {
          await this.loadPoolConfiguration();
          await this.initializeHistoricalData();
          this.logger.getLogSummary();

          console.log('‚úÖ LP Farming Monitor ready on Ethereum Mainnet!');
          console.log(`üåê Network: ${CHAIN_CONFIG.name}`);
          console.log(
            `üéØ Target Pool: ${this.token0Symbol}/${this.token1Symbol}`
          );
          console.log(
            `üí∞ Fee Tier: ${this.fee ? this.fee / 10000 : 'Unknown'}%`
          );
          console.log(`üìè Tick Spacing: ${this.tickSpacing}`);
        } catch (mainnetError) {
          console.error('‚ùå Mainnet initialization also failed:', mainnetError);
          throw mainnetError;
        }
      } else {
        throw error;
      }
    }
  }

  private async loadPoolConfiguration(): Promise<void> {
    console.log(`üîç Loading pool configuration...`);

    try {
      // Load basic pool info
      const [token0, token1, slot0] = await Promise.all([
        this.client.readContract({
          address: this.poolAddress,
          abi: poolAbi,
          functionName: 'token0',
        }) as Promise<Address>,
        this.client.readContract({
          address: this.poolAddress,
          abi: poolAbi,
          functionName: 'token1',
        }) as Promise<Address>,
        this.client.readContract({
          address: this.poolAddress,
          abi: poolAbi,
          functionName: 'slot0',
        }) as Promise<any>,
      ]);

      // Load pool parameters with fallbacks
      let fee = 500n; // 0.05% default for USDC/ETH
      let tickSpacing = 10n; // Default spacing

      try {
        fee = BigInt(
          (await this.client.readContract({
          address: this.poolAddress,
          abi: poolAbi,
          functionName: 'fee',
          })) as number
        );
      } catch {
        console.warn('‚ö†Ô∏è Using default fee: 0.05%');
      }

      try {
        tickSpacing = BigInt(
          (await this.client.readContract({
          address: this.poolAddress,
          abi: poolAbi,
          functionName: 'tickSpacing',
          })) as number
        );
      } catch {
        console.warn('‚ö†Ô∏è Using default tick spacing: 10');
      }

      // Load token information
      const [decimals0, decimals1, symbol0, symbol1] = await Promise.all([
        this.client.readContract({
          address: token0,
          abi: erc20Abi,
          functionName: 'decimals',
        }) as Promise<number>,
        this.client.readContract({
          address: token1,
          abi: erc20Abi,
          functionName: 'decimals',
        }) as Promise<number>,
        this.client.readContract({
          address: token0,
          abi: erc20Abi,
          functionName: 'symbol',
        }) as Promise<string>,
        this.client.readContract({
          address: token1,
          abi: erc20Abi,
          functionName: 'symbol',
        }) as Promise<string>,
      ]);

      // Store configuration
      this.token0Address = token0;
      this.token1Address = token1;
      this.fee = Number(fee);
      this.tickSpacing = Number(tickSpacing);
      this.token0Decimals = decimals0;
      this.token1Decimals = decimals1;
      this.token0Symbol = symbol0;
      this.token1Symbol = symbol1;

      console.log(`‚úÖ Pool loaded: ${symbol0}/${symbol1}`);
      console.log(`   üí∞ Fee: ${Number(fee) / 10000}%`);
      console.log(`   üìè Tick Spacing: ${Number(tickSpacing)}`);
      console.log(`   üîó Token0: ${token0} (${decimals0} decimals)`);
      console.log(`   üîó Token1: ${token1} (${decimals1} decimals)`);
    } catch (error) {
      console.error('‚ùå Failed to load pool configuration:', error);
      throw error;
    }
  }

  private async initializeHistoricalData(): Promise<void> {
    console.log('üìä Initializing historical data...');

    try {
      // Get current pool state
      const slot0 = (await this.client.readContract({
        address: this.poolAddress,
        abi: poolAbi,
        functionName: 'slot0',
      })) as any;

      const currentTick = Number(slot0[1]);
      const sqrtPriceX96 = slot0[0] as bigint;
      const currentPrice = price1Per0FromSqrt(
        sqrtPriceX96,
        this.token0Decimals!,
        this.token1Decimals!
      );

      // Calculate current bin
      const currentBin = Math.floor(currentTick / this.tickSpacing!);

      // Initialize tracking
      this.currentBin = currentBin;
      this.lastBinChangeTimestamp = Math.floor(Date.now() / 1000);

      // Add to history
      const timestamp = Date.now();
      this.binHistory.push({ bin: currentBin, timestamp, price: currentPrice });
      this.priceHistory.push({ price: currentPrice, timestamp });

      console.log(
        `‚úÖ Initialized at bin ${currentBin}, price ${currentPrice.toFixed(6)}`
      );
    } catch (error) {
      console.error('‚ùå Failed to initialize historical data:', error);
      // Continue without historical data
    }
  }

  startMonitoring(): void {
    console.log('\nüéØ Starting Advanced LP Farming Monitor...');
    console.log('üìä Data collection includes:');
    console.log('   üîÑ Chi ti·∫øt bin changes (t·ª´ bin n√†o sang bin n√†o)');
    console.log('   üìè Kho·∫£ng c√°ch ƒë·∫øn edge tr√°i v√† ph·∫£i c·ªßa bin');
    console.log('   üí∞ APR calculation v√† tracking');
    console.log('   üéØ LP opportunity scoring (0-100)');
    console.log('   üìà Impermanent loss monitoring');
    console.log('   üö® Real-time alerts cho farming opportunities');

    console.log('\nüé® Risk Zones:');
    console.log('   üö® DANGER (‚â§10%): Tr√°nh add LP - r·∫•t g·∫ßn edge');
    console.log('   ‚ö†Ô∏è  WARNING (10-20%): C·∫ßn c·∫©n th·∫≠n - kh√° g·∫ßn edge');
    console.log('   ‚úÖ SAFE (20-35%): An to√†n ƒë·ªÉ add LP');
    console.log('   üéØ OPTIMAL (>35%): Tuy·ªát v·ªùi cho LP farming!');

    this.startSwapEventListener();
    this.startPeriodicAnalysis();
    this.startDashboard();

    console.log('\nüöÄ LP Farming Monitor is now LIVE!');
  }

  private startSwapEventListener(): void {
    console.log('üëÇ Starting swap event listener...');

    // Try to start event listener, but fallback to polling if it fails
    try {
    this.client.watchEvent({
      address: this.poolAddress,
      event: swapEventAbi[0],
        onLogs: async (logs: any[]) => {
        for (const log of logs) {
            try {
              await this.processSwapEvent(log);
            } catch (error) {
              console.error('‚ùå Error processing swap event:', error);
            }
          }
        },
        onError: (error: any) => {
          console.error('‚ùå Swap event listener error:', error);
          console.log('üîÑ Event listening failed, using polling-only mode...');
          // Don't restart - just use polling
        },
      });
    } catch (error) {
            console.log(
        '‚ùå Failed to start event listener, using polling-only mode...'
      );
    }
  }

  private async processSwapEvent(log: Log): Promise<void> {
    const args = (log as any).args;
    if (!args) return;

    const tick = Number(args[6]);
    const sqrtPriceX96 = args[4] as bigint;
    const liquidity = args[5] as bigint;

    // Calculate bin and price
    const bin = Math.floor(tick / this.tickSpacing!);
    const price = price1Per0FromSqrt(
      sqrtPriceX96,
      this.token0Decimals!,
      this.token1Decimals!
    );

    // Get block info
    const block = await this.client.getBlock({ blockHash: log.blockHash! });
    const timestamp = Number(block.timestamp);
    const blockNumber = Number(block.number);

    // Check for bin change
    if (this.currentBin !== undefined && bin !== this.currentBin) {
      console.log(`üîÑ BIN CHANGE: ${this.currentBin} ‚Üí ${bin} (Tick: ${tick})`);
      await this.handleBinChange({
        fromBin: this.currentBin,
        toBin: bin,
        tick,
        price,
        sqrtPriceX96,
        liquidity: liquidity.toString(),
        blockNumber,
        blockTimestamp: timestamp,
        transactionHash: log.transactionHash || undefined,
      });
    }

    // Update current state
    this.currentBin = bin;
    this.previousBin = this.currentBin;

    // Update price history
    this.priceHistory.push({ price, timestamp: Date.now() });
    if (this.priceHistory.length > 1000) {
      this.priceHistory = this.priceHistory.slice(-500); // Keep last 500 records
    }
  }

  private async handleBinChange(data: {
    fromBin: number;
    toBin: number;
    tick: number;
    price: number;
    sqrtPriceX96: bigint;
    liquidity: string;
    blockNumber: number;
    blockTimestamp: number;
    transactionHash?: string;
  }): Promise<void> {
    const now = Date.now();
    const currentTimestamp = Math.floor(now / 1000);

    // Calculate bin change metrics
    const binDirection = data.toBin > data.fromBin ? 'up' : 'down';
    const ticksChanged =
      Math.abs(data.toBin - data.fromBin) * this.tickSpacing!;

    // Calculate timing metrics
    let timeSinceLastBinChange = 0;
    let binDuration = 0;

    if (this.lastBinChangeTimestamp) {
      timeSinceLastBinChange = currentTimestamp - this.lastBinChangeTimestamp;
      binDuration = timeSinceLastBinChange;
    }

    // Calculate price change
    const lastPrice =
      this.priceHistory.length > 0
        ? this.priceHistory[this.priceHistory.length - 1].price
        : data.price;
    const priceChangePercentage = ((data.price - lastPrice) / lastPrice) * 100;

    // Create bin change data
    const binChangeData: BinChangeData = {
      timestamp: new Date().toISOString(),
      blockNumber: data.blockNumber,
      transactionHash: data.transactionHash,
      tick: data.tick,
      sqrtPriceX96: data.sqrtPriceX96.toString(),
      price: data.price,
      liquidity: data.liquidity,
      fromBin: data.fromBin,
      toBin: data.toBin,
      binChangeDirection: binDirection,
      ticksChanged,
      priceChangePercentage,
      timeSinceLastBinChange,
      binDuration,
      blockTimestamp: data.blockTimestamp,
    };

    // Log bin change
    this.logger.logBinChange(binChangeData);

    // Update bin durations for statistics
    if (binDuration > 0) {
      this.binDurations.push(binDuration);
      if (this.binDurations.length > 100) {
        this.binDurations = this.binDurations.slice(-50);
      }
    }

    // Update tracking
    this.lastBinChangeTimestamp = currentTimestamp;
    this.binHistory.push({
      bin: data.toBin,
      timestamp: now,
      price: data.price,
    });

    // Immediately analyze LP opportunity after bin change
    await this.analyzeLPOpportunity(data.tick, data.price, data.liquidity);
  }

  private startPeriodicAnalysis(): void {
    console.log('‚è∞ Starting periodic analysis...');

    // Main analysis loop
    setInterval(async () => {
      try {
        await this.performPeriodicAnalysis();
      } catch (error) {
        console.error('‚ùå Periodic analysis error:', error);
      }
    }, 10000); // 10 seconds - less frequent logging

    // APR tracking (every 2 minutes for testing)
    setInterval(async () => {
      try {
        await this.updateAPRTracking();
    } catch (error) {
        console.error('‚ùå APR tracking error:', error);
      }
    }, 2 * 60 * 1000);
    }

  private async performPeriodicAnalysis(): Promise<void> {
    // Get current pool state
    const slot0 = (await this.client.readContract({
      address: this.poolAddress,
      abi: poolAbi,
      functionName: 'slot0',
    })) as any;

    let liquidity = '0';
    try {
      const liquidityResult = (await this.client.readContract({
        address: this.poolAddress,
        abi: poolAbi,
        functionName: 'liquidity',
      })) as bigint;
      liquidity = liquidityResult.toString();
    } catch {
      // Use fallback liquidity
    }

    const tick = Number(slot0[1]);
    const sqrtPriceX96 = slot0[0] as bigint;
    const price = price1Per0FromSqrt(
      sqrtPriceX96,
      this.token0Decimals!,
      this.token1Decimals!
    );

    // Get high precision price
    const precisePrice = price1Per0FromSqrtPrecise(
      sqrtPriceX96,
      this.token0Decimals!,
      this.token1Decimals!,
      18 // 18 decimal precision
    );

    const blockNumber = await this.client.getBlockNumber();

    // Store precise price for dashboard display
    this.currentPrecisePrice = precisePrice;

    // Check for bin change in periodic analysis
    const bin = Math.floor(tick / this.tickSpacing!);
    if (this.currentBin !== undefined && bin !== this.currentBin) {
      console.log(`üîÑ BIN CHANGE: ${this.currentBin} ‚Üí ${bin} (Tick: ${tick})`);
      await this.handleBinChange({
        fromBin: this.currentBin,
        toBin: bin,
        tick,
        price,
        sqrtPriceX96,
        liquidity,
        blockNumber: Number(blockNumber),
        blockTimestamp: Math.floor(Date.now() / 1000),
        transactionHash: undefined, // No transaction hash for periodic analysis
      });
    }

    // Update current bin
    this.currentBin = bin;

    // Analyze LP opportunity and store edge analysis
    const edgeAnalysis = await this.analyzeLPOpportunity(
      tick,
      price,
      liquidity,
      Number(blockNumber)
    );
    
    // Store edge analysis for dashboard display
    this.currentEdgeAnalysis = edgeAnalysis;
  }

  private async analyzeLPOpportunity(
    tick: number,
    price: number,
    liquidity: string,
    blockNumber?: number
  ): Promise<BinEdgeAnalysis> {
    // Perform bin edge analysis
    const binAnalysis = analyzeBinEdges(
      tick,
      this.tickSpacing!,
      price,
      this.token0Decimals!,
      this.token1Decimals!
    );

    // Calculate opportunity score
    const volume24h =
      this.volumeHistory.length > 0
        ? this.volumeHistory.reduce((sum, v) => sum + v.volume, 0)
        : 0;
    const volatility = this.calculatePriceVolatility();

    const opportunityScore = LPFarmingLogger.calculateOpportunityScore(
      binAnalysis.nearestEdgeDistancePct,
      undefined, // APR data will be added later
      volume24h,
      volatility
    );

    // Create LP opportunity data
    const opportunityData: LPOpportunityData = {
      timestamp: new Date().toISOString(),
      blockNumber: blockNumber || 0,
      currentTick: tick,
      currentPrice: price,
      currentBin: binAnalysis.currentBin,
      distanceToLowerEdgePct: binAnalysis.distanceToLowerEdgePct,
      distanceToUpperEdgePct: binAnalysis.distanceToUpperEdgePct,
      nearestEdgeSide: binAnalysis.nearestEdgeSide,
      nearestEdgeDistancePct: binAnalysis.nearestEdgeDistancePct,
      riskLevel: binAnalysis.riskLevel,
      riskDescription: binAnalysis.riskDescription,
      lpRecommendation: binAnalysis.lpRecommendation,
      binLowerPrice: binAnalysis.priceAtBinLower,
      binUpperPrice: binAnalysis.priceAtBinUpper,
      liquidity,
      volume24h,
      opportunityScore,
    };

    // Log significant LP opportunities only when risk level changes
    if (
      binAnalysis.riskLevel === 'optimal' ||
      binAnalysis.riskLevel === 'danger' ||
      binAnalysis.riskLevel === 'warning'
    ) {
      this.logger.logLPOpportunity(opportunityData);
    }

    // Track consecutive safe opportunities
    if (
      binAnalysis.lpRecommendation === 'add' ||
      binAnalysis.lpRecommendation === 'excellent'
    ) {
      this.consecutiveSafeOpportunities++;
    } else {
      this.consecutiveSafeOpportunities = 0;
    }

    // Log detailed data
    const detailedData: DetailedPoolData = {
      timestamp: new Date().toISOString(),
      blockNumber: blockNumber || 0,
      tick,
      sqrtPriceX96: BigInt(0).toString(), // Will be populated with actual value
      price,
      liquidity,
      token0Symbol: this.token0Symbol!,
      token1Symbol: this.token1Symbol!,
      token0Address: this.token0Address!,
      token1Address: this.token1Address!,
      binAnalysis,
      eventType: 'periodic_analysis',
      severity:
        binAnalysis.riskLevel === 'danger'
          ? 'critical'
          : binAnalysis.riskLevel === 'warning'
          ? 'warning'
          : 'info',
    };

    this.logger.logDetailedData(detailedData);
    
    // Return the bin analysis for dashboard display
    return binAnalysis;
  }

  private async updateAPRTracking(): Promise<void> {
    const now = Date.now();

    // Skip if updated recently
    if (now - this.lastAPRUpdate < 1 * 60 * 1000) {
      // 1 minute minimum interval
      return;
    }

    try {
      // Calculate mock APR based on fees and activity
      // In real implementation, you'd fetch actual volume and fees data
      const mockVolume24h = 50000; // $50K daily volume estimate
      const mockFees24h = mockVolume24h * (this.fee! / 10000); // Fee percentage
      const mockTVL = 1000000; // $1M TVL estimate

      const aprCalculation = calculateAPR(
        mockVolume24h,
        mockFees24h,
        mockTVL,
        this.fee! / 10000
      );

      const aprData: APRTrackingData = {
        timestamp: new Date().toISOString(),
        date: new Date().toISOString().split('T')[0], // YYYY-MM-DD
        currentAPR: aprCalculation.currentAPR,
        projectedAPR: aprCalculation.projectedAPR,
        feeAPR: aprCalculation.feeAPR,
        volume24h: mockVolume24h,
        fees24h: mockFees24h,
        totalValueLocked: mockTVL,
        volumeToTVLRatio: aprCalculation.volumeToTVLRatio,
        aprConfidence: aprCalculation.aprConfidence,
        priceVolatility: this.calculatePriceVolatility(),
        notes: `Consecutive safe opportunities: ${this.consecutiveSafeOpportunities}`,
      };

      this.logger.logAPRTracking(aprData);
      this.lastAPRUpdate = now;
      console.log(`üìà APR Updated: ${aprCalculation.currentAPR.toFixed(2)}% | Volume: $${mockVolume24h.toLocaleString()}`);
    } catch (error) {
      console.error('‚ùå Failed to update APR tracking:', error);
    }
  }

  private calculatePriceVolatility(): number {
    if (this.priceHistory.length < 10) return 0;

    const recentPrices = this.priceHistory.slice(-20).map((p) => p.price);
    const mean =
      recentPrices.reduce((sum, price) => sum + price, 0) / recentPrices.length;
    const variance =
      recentPrices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) /
      recentPrices.length;
    const volatility = Math.sqrt(variance) / mean; // Coefficient of variation

    return volatility;
  }

  // ==================== REAL-TIME DASHBOARD ====================

  private startDashboard(): void {
    console.log('üñ•Ô∏è Starting real-time dashboard...');

    this.dashboardInterval = setInterval(() => {
      this.displayDashboard();
    }, 30000); // Update dashboard every 30 seconds (less frequent)
  }

  private displayDashboard(): void {
    const uptime = Math.floor((Date.now() - this.monitorStartTime) / 1000);
    const hours = Math.floor(uptime / 3600);
    const minutes = Math.floor((uptime % 3600) / 60);

    console.clear();
    console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log('‚ïë                   üéØ LP FARMING DASHBOARD üéØ                    ‚ïë');
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log(`‚ïë Pool: ${this.token0Symbol}/${this.token1Symbol} | Network: ${CHAIN_CONFIG.name} | Uptime: ${hours}h ${minutes}m ‚ïë`);
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');

    if (this.currentBin !== undefined && this.currentPrecisePrice) {
      console.log(`‚ïë üìç Current Bin: ${this.currentBin} | Price: ${this.currentPrecisePrice} ‚ïë`);
      
        // Display edge distances if available
        if (this.currentEdgeAnalysis) {
          const lowerDistance = (this.currentEdgeAnalysis.distanceToLowerEdgePct * 100).toFixed(6);
          const upperDistance = (this.currentEdgeAnalysis.distanceToUpperEdgePct * 100).toFixed(6);
          const riskLevel = this.currentEdgeAnalysis.riskLevel.toUpperCase();
          console.log(`‚ïë üìè Edge Distances: Lower ${lowerDistance}% | Upper ${upperDistance}% ‚ïë`);
          console.log(`‚ïë üéØ Risk Level: ${riskLevel} | Recommendation: ${this.currentEdgeAnalysis.lpRecommendation} ‚ïë`);
        }

      console.log(`‚ïë üìä Bin Changes: ${this.binHistory.length} | Safe Opportunities: ${this.consecutiveSafeOpportunities} ‚ïë`);
    }

    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    console.log('‚ïë üéØ LP FARMING TIPS:                                           ‚ïë');
    console.log('‚ïë ‚Ä¢ ƒê·ª£i bin ·ªü v·ªã tr√≠ SAFE/OPTIMAL tr∆∞·ªõc khi add LP              ‚ïë');
    console.log('‚ïë ‚Ä¢ Theo d√µi edge distances ƒë·ªÉ t·ªëi ∆∞u timing                    ‚ïë');
    console.log('‚ïë ‚Ä¢ Rebalance khi distance ƒë·∫øn edge < 15%                       ‚ïë');
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
    console.log('\nüí° Press Ctrl+C to stop monitoring...\n');
  }

  // ==================== CLEANUP ====================

  public cleanup(): void {
    if (this.dashboardInterval) {
      clearInterval(this.dashboardInterval);
    }
    console.log('üßπ LP Farming Monitor cleanup completed');
  }

  /**
   * Get current high precision price
   * Returns exact price like "0.00022828235"
   */
  public async getCurrentPrecisePrice(): Promise<string> {
    try {
      const slot0 = (await this.client.readContract({
        address: this.poolAddress,
        abi: poolAbi,
        functionName: 'slot0',
      })) as any;

      const sqrtPriceX96 = slot0[0] as bigint;
      const precisePrice = price1Per0FromSqrtPrecise(
        sqrtPriceX96,
        this.token0Decimals!,
        this.token1Decimals!,
        18 // 18 decimal precision
      );

      return precisePrice;
    } catch (error) {
      console.error('‚ùå Failed to get precise price:', error);
      return '0.000000000000000000';
    }
  }
}

// ==================== MAIN EXECUTION ====================

async function main() {
  const monitor = new LPFarmingMonitor();

  // Banner
  console.log('');
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë          üéØ UNISWAP V3 LP FARMING MONITOR      ‚ïë');
  console.log('‚ïë           Multi-Network Smart Edition          ‚ïë');
  console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
  console.log('‚ïë  üìä Advanced Bin Tracking & Analysis          ‚ïë');
  console.log('‚ïë  üí∞ APR Calculation & Optimization            ‚ïë');
  console.log('‚ïë  üéØ LP Opportunity Scoring                     ‚ïë');
  console.log('‚ïë  üìà Impermanent Loss Monitoring               ‚ïë');
  console.log('‚ïë  üö® Real-time Farming Alerts                  ‚ïë');
  console.log('‚ïë  üîÑ Auto Katana/Mainnet Fallback              ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  console.log('');
  console.log(
    'üåê Attempting connection: Katana Network ‚Üí Ethereum Mainnet fallback'
  );
  console.log('');

  try {
    // Initialize monitor
    await monitor.initialize();

    // Start monitoring
    monitor.startMonitoring();

    console.log('\nüéØ LP Farming Monitor started successfully!');
    console.log('üìä Data ƒë∆∞·ª£c ghi v√†o multiple CSV files:');
    console.log(`   üîÑ Bin Changes: ./data/${config.BIN_CHANGES_CSV}`);
    console.log(
      `   üí∞ LP Opportunities: ./data/${config.LP_OPPORTUNITIES_CSV}`
    );
    console.log(`   üìà APR Tracking: ./data/${config.APR_TRACKING_CSV}`);
    console.log('\nüñ•Ô∏è Real-time dashboard s·∫Ω hi·ªÉn th·ªã sau 10 gi√¢y...');

    // Graceful shutdown handling
    const gracefulShutdown = () => {
      console.log('\nüõë Shutting down LP Farming Monitor...');
      monitor.cleanup();
      console.log('üëã Monitor stopped. All data saved to CSV files.');
      console.log('üìä Check the data folder for complete farming analytics.');
      process.exit(0);
    };

    process.on('SIGINT', gracefulShutdown);
    process.on('SIGTERM', gracefulShutdown);
    process.on('SIGHUP', gracefulShutdown);

    // Handle uncaught errors
    process.on('uncaughtException', (error) => {
      console.error('üí• Uncaught Exception:', error);
      monitor.cleanup();
      process.exit(1);
    });

    process.on('unhandledRejection', (reason, promise) => {
      console.error('üí• Unhandled Rejection at:', promise, 'reason:', reason);
      monitor.cleanup();
      process.exit(1);
    });
  } catch (error) {
    console.error('‚ùå Failed to start LP Farming Monitor:', error);
    console.error('');
    console.error('üîß Troubleshooting:');
    console.error('   1. Check your network connection to Katana/Ronin');
    console.error('   2. Verify the pool address is correct');
    console.error('   3. Ensure you have proper RPC access');
    console.error('   4. Check if the pool contract exists on Katana');
    console.error('');
    process.exit(1);
  }
}

// Start the application
console.log('üöÄ Starting LP Farming Monitor...');
main().catch((error) => {
  console.error('üí• Critical error in main():', error);
  process.exit(1);
});
